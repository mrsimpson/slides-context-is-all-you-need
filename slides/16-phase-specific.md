---
layout: default
---

# Different Phases Need Different Context

<div class="grid grid-cols-3 gap-8 mt-12">

<div class="text-center">
<div class="inline-block w-6 h-6 bg-blue-500 rounded text-white text-xs flex items-center justify-center text-6xl text-blue-500 mx-auto mb-4">ğŸ“‹</div>
<div class="text-lg font-bold">Project Start</div>
<div class="text-sm mt-2">Requirements, architecture, similar projects</div>
</div>

<div class="text-center">
<div class="inline-block w-6 h-6 bg-blue-500 rounded text-white text-xs flex items-center justify-center text-6xl text-green-500 mx-auto mb-4">ğŸ”§</div>
<div class="text-lg font-bold">Implementation</div>
<div class="text-sm mt-2">Relevant code, patterns, APIs</div>
</div>

<div class="text-center">
<div class="inline-block w-6 h-6 bg-red-500 rounded text-white text-xs flex items-center justify-center text-6xl text-red-500 mx-auto mb-4">ğŸ›</div>
<div class="text-lg font-bold">Debugging</div>
<div class="text-sm mt-2">Error logs, related code, recent changes</div>
</div>

</div>

<!--
Here's the breakthrough insight that changed everything for me: relevant context is heavily dependent on the current development phase.

When you're starting a project, you need requirements, architecture documentation, and examples of similar projects. Detailed code implementations are irrelevant and just add noise.

When you're implementing, you need the relevant code files, established patterns, and API documentation. High-level requirements documents become noise.

When you're debugging, you need error logs, the specific code involved, and recent changes. Everything else is distraction.

This phase-awareness is what makes Context Engineering so powerful - it's not just about having information, it's about having the RIGHT information for what you're trying to accomplish right now.
-->
